name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

permissions:
  contents: read

jobs:
  backend:
    name: Python Backend
    runs-on: ubuntu-latest
    # Optional: Use GitHub Environments for different deployment stages
    # Uncomment and set environment name to use environment-specific secrets:
    # environment: production  # or staging, development
    env:
      ACTIONS_STEP_DEBUG: true
      ACTIONS_RUNNER_DEBUG: true
      UV_PROJECT_ENVIRONMENT: .venv-ci
      UV_LINK_MODE: copy
      # Suppress Node.js punycode deprecation warning (DEP0040) from transitive dependencies
      NODE_OPTIONS: --no-deprecation
      # Database password is test value for CI (self-contained PostgreSQL setup)
      # For production deployments, use GitHub Secrets: ${{ secrets.POSTGRES_PASSWORD }}
      DATABASE_URL: postgresql+asyncpg://postgres:Cthulhu1@localhost:5432/mythos_unit
      DATABASE_NPC_URL: postgresql+asyncpg://postgres:Cthulhu1@localhost:5432/mythos_unit
      # Using GitHub Secrets for application secrets (CI-specific naming convention)
      # Provide test defaults if secrets are not set (empty secrets become empty strings in GitHub Actions)
      MYTHOSMUD_ADMIN_PASSWORD: ${{ secrets.MYTHOSMUD_ADMIN_PASSWORD_CI || 'test-admin-password-for-development' }}
      MYTHOSMUD_SECRET_KEY: ${{ secrets.MYTHOSMUD_SECRET_KEY_CI || 'test-secret-key-for-development' }}
      MYTHOSMUD_JWT_SECRET: ${{ secrets.MYTHOSMUD_JWT_SECRET_CI || 'test-jwt-secret-key-for-development' }}
      MYTHOSMUD_RESET_TOKEN_SECRET: ${{ secrets.MYTHOSMUD_RESET_TOKEN_SECRET_CI || 'test-reset-token-secret-for-development' }}
      MYTHOSMUD_VERIFICATION_TOKEN_SECRET: ${{ secrets.MYTHOSMUD_VERIFICATION_TOKEN_SECRET_CI || 'test-verification-token-secret-for-development' }}
    steps:
      - name: Harden the runner (Audit all outbound calls)
        if: ${{ !env.ACT }}
        uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76 # v2.14.0
        with:
          egress-policy: audit

      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
          submodules: recursive
          token: ${{ secrets.PRIVATE_SUBMODULE_PAT }}

      - name: Set up Python
        uses: actions/setup-python@83679a892e2d95755f2dac6acb0bfd1e9ac5d548 # v6.1.0
        with:
          python-version: '3.12'
      - name: Install uv
        run: |
          curl -LsSf https://astral.sh/uv/install.sh | sh
          echo "$HOME/.local/bin" >> $GITHUB_PATH
      - name: Install dependencies
        run: |
          # Use shared script for consistent dependency installation across all environments
          # Use activation mode (not explicit --python) to handle symlinked venv Pythons correctly
          # This ensures packages are installed into the venv's site-packages, not the base Python's
          VENV_NAME=.venv-ci USE_EXPLICIT_PYTHON=false bash scripts/install_ci_dependencies.sh
      - name: Install Playwright browsers
        run: |
          # Use the same venv Python as dependency installation
          .venv-ci/bin/python -m playwright install chromium
          .venv-ci/bin/python -m playwright install-deps chromium
      - name: Install PostgreSQL 18
        if: ${{ !env.ACT }}
        run: |
          sudo apt-get update
          sudo apt-get install -y wget lsb-release gnupg
          wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo gpg --dearmor -o /usr/share/keyrings/postgresql-keyring.gpg
          echo "deb [signed-by=/usr/share/keyrings/postgresql-keyring.gpg] http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main" | sudo tee /etc/apt/sources.list.d/pgdg.list
          sudo apt-get update
          sudo apt-get install -y postgresql-18 postgresql-contrib-18
      - name: Start PostgreSQL service and initialize databases
        run: |
          # Determine workspace path (Docker uses /workspace, GitHub Actions uses $GITHUB_WORKSPACE or pwd)
          WORKSPACE_PATH="${GITHUB_WORKSPACE:-/workspace}"
          if [ ! -d "$WORKSPACE_PATH" ]; then
            WORKSPACE_PATH=$(pwd)
          fi
          # Start PostgreSQL - try service command first, fall back to direct start
          service postgresql start 2>/dev/null || \
          (command -v sudo >/dev/null 2>&1 && sudo service postgresql start) || \
          (PGDATA=$(find /var/lib/postgresql -type d -name "main" 2>/dev/null | head -1) && \
           [ -n "$PGDATA" ] && su postgres -c "postgres -D $PGDATA" &) || true
          sleep 3
          pg_isready -U postgres || (sleep 3 && pg_isready -U postgres)
          # Set postgres user password to match DATABASE_URL
          # Use su postgres instead of sudo -u postgres for Docker container compatibility
          su postgres -c "psql -c \"ALTER USER postgres PASSWORD 'Cthulhu1';\"" || \
          (command -v sudo >/dev/null 2>&1 && sudo -u postgres psql -c "ALTER USER postgres PASSWORD 'Cthulhu1';")
          # Initialize database schema and apply migrations
          # Use su postgres for Docker compatibility, fall back to sudo for GitHub Actions
          su postgres -c "psql -v ON_ERROR_STOP=1 -f $WORKSPACE_PATH/db/roles/roles.sql" || \
          (command -v sudo >/dev/null 2>&1 && sudo -u postgres psql -v ON_ERROR_STOP=1 -f db/roles/roles.sql)
          su postgres -c "psql -v ON_ERROR_STOP=1 -f $WORKSPACE_PATH/db/databases/databases.sql" || \
          (command -v sudo >/dev/null 2>&1 && sudo -u postgres psql -v ON_ERROR_STOP=1 -f db/databases/databases.sql)
          # Apply authoritative schema with error checking
          echo "Applying authoritative schema..."
          if ! su postgres -c "psql -v ON_ERROR_STOP=1 -d mythos_unit -f $WORKSPACE_PATH/db/authoritative_schema.sql" 2>&1; then
            if command -v sudo >/dev/null 2>&1; then
              if ! sudo -u postgres psql -v ON_ERROR_STOP=1 -d mythos_unit -f db/authoritative_schema.sql 2>&1; then
                echo "ERROR: Failed to apply authoritative schema"
                exit 1
              fi
            else
              echo "ERROR: Failed to apply authoritative schema"
              exit 1
            fi
          fi
          echo "✓ Schema applied successfully"
          # Verify migrations were applied correctly - check for container_item_instance_id column
          # Use explicit schema qualification and better error handling
          # Prefer sudo -u postgres (no password prompt) over su postgres (requires password)
          COLUMN_CHECK=$((command -v sudo >/dev/null 2>&1 && sudo -u postgres psql -t -A -d mythos_unit -c "SELECT EXISTS(SELECT 1 FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'containers' AND column_name = 'container_item_instance_id');" 2>&1) || \
            (su postgres -c "psql -t -A -d mythos_unit -c \"SELECT EXISTS(SELECT 1 FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'containers' AND column_name = 'container_item_instance_id');\"" 2>&1))
          # Strip whitespace and check for actual result
          COLUMN_CHECK=$(echo "$COLUMN_CHECK" | tr -d '[:space:]')
          if [ "$COLUMN_CHECK" != "t" ]; then
            echo "ERROR: container_item_instance_id column not found in containers table after schema application"
            echo "Column check result: '$COLUMN_CHECK'"
            echo "Verifying containers table exists..."
            (command -v sudo >/dev/null 2>&1 && sudo -u postgres psql -d mythos_unit -c "SELECT column_name, data_type FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'containers' ORDER BY ordinal_position;") || \
              su postgres -c "psql -d mythos_unit -c \"SELECT column_name, data_type FROM information_schema.columns WHERE table_schema = 'public' AND table_name = 'containers' ORDER BY ordinal_position;\""
            exit 1
          fi
          echo "✓ Verified container_item_instance_id column exists in containers table"
          su postgres -c "psql -d mythos_unit -f $WORKSPACE_PATH/data/db/00_world_and_emotes.sql" || \
          (command -v sudo >/dev/null 2>&1 && sudo -u postgres psql -d mythos_unit -f data/db/00_world_and_emotes.sql)
          su postgres -c "psql -d mythos_unit -f $WORKSPACE_PATH/data/db/01_professions.sql" || \
          (command -v sudo >/dev/null 2>&1 && sudo -u postgres psql -d mythos_unit -f data/db/01_professions.sql)
          su postgres -c "psql -d mythos_unit -f $WORKSPACE_PATH/data/db/02_item_prototypes.sql" || \
          (command -v sudo >/dev/null 2>&1 && sudo -u postgres psql -d mythos_unit -f data/db/02_item_prototypes.sql)
          su postgres -c "psql -d mythos_unit -f $WORKSPACE_PATH/data/db/03_npc_definitions.sql" || \
          (command -v sudo >/dev/null 2>&1 && sudo -u postgres psql -d mythos_unit -f data/db/03_npc_definitions.sql)
      - name: Lint with ruff
        run: |
          source .venv-ci/bin/activate
          python -m ruff check --line-length=120 server/
      - name: Type check with mypy
        run: |
          source .venv-ci/bin/activate
          # Use pre-commit to run mypy with identical config to local development
          pre-commit run mypy --all-files
      - name: Set up test environment file
        run: |
          # Create test environment file from example for CI
          # CI already has all env vars set, but conftest.py validates the file exists
          mkdir -p server/tests
          if [ -f env.unit_test.example ]; then
            cp env.unit_test.example server/tests/.env.unit_test
            echo "Created server/tests/.env.unit_test from example"
          else
            echo "Warning: env.unit_test.example not found, creating minimal .env.unit_test"
            # Use environment variables that are already set in the job env section
            cat > server/tests/.env.unit_test << 'EOF'
          SERVER_PORT=54731
          EOF
            echo "DATABASE_URL=${DATABASE_URL}" >> server/tests/.env.unit_test
            echo "DATABASE_NPC_URL=${DATABASE_NPC_URL}" >> server/tests/.env.unit_test
            echo "MYTHOSMUD_ADMIN_PASSWORD=${MYTHOSMUD_ADMIN_PASSWORD}" >> server/tests/.env.unit_test
            echo "MYTHOSMUD_SECRET_KEY=${MYTHOSMUD_SECRET_KEY}" >> server/tests/.env.unit_test
            echo "MYTHOSMUD_JWT_SECRET=${MYTHOSMUD_JWT_SECRET}" >> server/tests/.env.unit_test
            echo "MYTHOSMUD_RESET_TOKEN_SECRET=${MYTHOSMUD_RESET_TOKEN_SECRET}" >> server/tests/.env.unit_test
            echo "MYTHOSMUD_VERIFICATION_TOKEN_SECRET=${MYTHOSMUD_VERIFICATION_TOKEN_SECRET}" >> server/tests/.env.unit_test
          fi
      - name: Run tests with coverage
        run: |
          .venv-ci/bin/python scripts/run_test_ci.py
      - name: Check for excessive warnings
        run: |
          source .venv-ci/bin/activate
          # Temporarily disable --disable-warnings to check warning count
          # Fail if warnings exceed 100 (should be ~72 after fixes)
          # Use --override-ini to temporarily disable --disable-warnings
          WARNING_OUTPUT=$(uv run pytest server/tests/ -m "not slow and not e2e" -n auto --tb=short --override-ini=addopts="--strict-markers --strict-config" 2>&1 || true)
          WARNING_COUNT=$(echo "$WARNING_OUTPUT" | grep -oP '\d+ warnings' | grep -oP '\d+' | tail -1 || echo "0")
          if [ -z "$WARNING_COUNT" ]; then
            WARNING_COUNT=0
          fi
          echo "Warning count: $WARNING_COUNT"
          if [ "$WARNING_COUNT" -gt 100 ]; then
            echo "ERROR: Warning count ($WARNING_COUNT) exceeds threshold (100)"
            echo "$WARNING_OUTPUT" | tail -50
            exit 1
          fi
          echo "✓ Warning count ($WARNING_COUNT) is within acceptable range (≤100)"
      - name: Cache benchmark (LRU cache)
        run: |
          source .venv-ci/bin/activate
          python scripts/bench_cache.py
      - name: Cache benchmark (NPC cache)
        run: |
          source .venv-ci/bin/activate
          python scripts/bench_cache_npc.py
      - name: Cache benchmark (Profession cache)
        run: |
          source .venv-ci/bin/activate
          python scripts/bench_cache_professions.py
      - name: Upload performance metrics
        if: ${{ !env.ACT }}
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: perf-metrics
          path: artifacts/perf/
      - name: Upload coverage report
        if: ${{ !env.ACT }}
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f # v6.0.0
        with:
          name: coverage-html
          path: htmlcov/
      - name: Upload coverage to Codacy
        if: ${{ !env.ACT }}
        uses: codacy/codacy-coverage-reporter-action@v1.3.0
        with:
          project-token: ${{ secrets.CODACY_PROJECT_TOKEN }}
          coverage-reports: coverage.xml
          language: python
      - name: Cleanup PostgreSQL (for act)
        if: ${{ env.ACT }}
        run: |
          # Stop PostgreSQL gracefully when running with act to prevent hang
          service postgresql stop 2>/dev/null || \
          (command -v sudo >/dev/null 2>&1 && sudo service postgresql stop) || \
          pkill -f postgres || true
          sleep 1
      # FastAPI app smoke test removed; not needed for unit tests

  frontend:
    name: React Client
    runs-on: ubuntu-latest
    env:
      ACTIONS_STEP_DEBUG: true
      ACTIONS_RUNNER_DEBUG: true
      # Suppress Node.js punycode deprecation warning (DEP0040) from transitive dependencies
      NODE_OPTIONS: --no-deprecation
    defaults:
      run:
        working-directory: client
    steps:
      - name: Harden the runner (Audit all outbound calls)
        if: ${{ !env.ACT }}
        uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76 # v2.14.0
        with:
          egress-policy: audit

      - uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0
      - name: Set up Node.js
        uses: actions/setup-node@395ad3262231945c25e8478fd5baf05154b1d79f # v6.1.0
        with:
          node-version: '22'
      - name: Install dependencies
        run: npm ci
      - name: Lint with ESLint
        run: |
          npx eslint .
      - name: Run unit tests with coverage
        run: npm run test:coverage
      - name: Run E2E tests
        run: npm run test
      - name: Build React app
        run: npm run build
