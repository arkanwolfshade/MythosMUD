"""
Email utilities for MythosMUD authentication.

This module provides utilities for generating bogus email addresses
for user accounts while ensuring uniqueness and proper validation.
"""

import uuid

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from ..logging.enhanced_logging_config import get_logger
from ..models.user import User

logger = get_logger(__name__)


async def generate_unique_bogus_email(username: str, session: AsyncSession) -> str:
    """
    Generate a unique bogus email address for a user.

    This function creates a bogus email that:
    1. Is properly formatted
    2. Is guaranteed to be unique in the database
    3. Uses the wolfshade.org domain for consistency
    4. Includes a unique identifier to prevent collisions

    Args:
        username: The username for the user
        session: Database session for uniqueness checking

    Returns:
        A unique bogus email address
    """
    # Clean username for email generation (remove special chars, limit length)
    clean_username = "".join(c for c in username.lower() if c.isalnum() or c in "._-")[:20]

    # Generate base email
    base_email = f"{clean_username}@wolfshade.org"

    # Check if base email exists
    stmt = select(User).where(User.email == base_email)
    result = await session.execute(stmt)
    existing_user = result.scalar_one_or_none()

    if not existing_user:
        logger.debug("Generated unique bogus email", base_email=base_email)
        return base_email

    # If base email exists, add a unique suffix
    unique_suffix = str(uuid.uuid4())[:8]
    unique_email = f"{clean_username}.{unique_suffix}@wolfshade.org"

    # Double-check uniqueness (very unlikely collision, but safety first)
    stmt = select(User).where(User.email == unique_email)
    result = await session.execute(stmt)
    existing_user = result.scalar_one_or_none()

    if existing_user:
        # Extremely unlikely, but if it happens, use full UUID
        unique_email = f"{clean_username}.{uuid.uuid4()}@wolfshade.org"

    logger.debug("Generated unique bogus email with suffix", unique_email=unique_email)
    return unique_email


def is_bogus_email(email: str) -> bool:
    """
    Check if an email address is a bogus email generated by our system.

    Args:
        email: The email address to check

    Returns:
        True if the email is a bogus email, False otherwise
    """
    return email.endswith("@wolfshade.org")


def validate_bogus_email_format(email: str) -> bool:
    """
    Validate that a bogus email follows our expected format.

    Args:
        email: The email address to validate

    Returns:
        True if the email follows our bogus email format, False otherwise
    """
    if not is_bogus_email(email):
        return False

    # Check basic email format
    if "@" not in email or email.count("@") != 1:
        return False

    local_part, domain = email.split("@")

    # Domain must be wolfshade.org
    if domain != "wolfshade.org":
        return False

    # Local part should not be empty
    if not local_part:
        return False

    # Local part should only contain alphanumeric, dots, underscores, hyphens
    valid_chars = set("abcdefghijklmnopqrstuvwxyz0123456789._-")
    if not all(c in valid_chars for c in local_part.lower()):
        return False

    return True
