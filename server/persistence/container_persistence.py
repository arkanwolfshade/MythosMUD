"""
Container persistence operations for the unified container system.

As documented in the restricted archives of Miskatonic University, container
persistence requires careful handling to ensure proper storage and retrieval
of investigator artifacts across environmental props, wearable gear, and corpses.
"""

from __future__ import annotations

import json
from datetime import UTC, datetime
from typing import Any
from uuid import UUID

import psycopg2
from psycopg2.extras import RealDictCursor

from ..exceptions import DatabaseError, ValidationError
from ..structured_logging.enhanced_logging_config import get_logger
from ..utils.error_logging import log_and_raise
from .container_data import ContainerData
from .container_helpers import (
    build_update_query,
    fetch_container_items,
    parse_jsonb_column,
    update_container_items,
    validate_lock_state,
)

logger = get_logger(__name__)

# Re-export functions with original names for backward compatibility with tests
_fetch_container_items = fetch_container_items
_parse_jsonb_column = parse_jsonb_column


def create_container(  # pylint: disable=too-many-arguments,too-many-positional-arguments,too-many-locals  # Reason: Container creation requires many parameters and intermediate variables for complex container logic
    conn: Any,
    source_type: str,
    owner_id: UUID | None = None,
    room_id: str | None = None,
    entity_id: UUID | None = None,
    lock_state: str = "unlocked",
    capacity_slots: int = 20,
    weight_limit: int | None = None,
    decay_at: datetime | None = None,
    allowed_roles: list[str] | None = None,
    items_json: list[dict[str, Any]] | None = None,
    metadata_json: dict[str, Any] | None = None,
    container_item_instance_id: str | None = None,
) -> ContainerData:
    """
    Create a new container in the database.

    Args:
        conn: Database connection
        source_type: Type of container ('environment', 'equipment', 'corpse')
        owner_id: UUID of container owner (optional)
        room_id: Room identifier for environmental/corpse containers (optional)
        entity_id: Player/NPC UUID for wearable containers (optional)
        lock_state: Lock state ('unlocked', 'locked', 'sealed')
        capacity_slots: Maximum number of inventory slots (1-20)
        weight_limit: Optional maximum weight capacity
        decay_at: Timestamp when corpse container should decay (optional)
        allowed_roles: List of role names allowed to access container (optional)
        items_json: List of InventoryStack items (optional)
        metadata_json: Optional metadata dictionary (optional)
        container_item_instance_id: Item instance ID that IS this container (optional)

    Returns:
        ContainerData: The created container data

    Raises:
        ValidationError: If validation fails
        DatabaseError: If database operation fails
    """
    # Validate source_type
    if source_type not in ("environment", "equipment", "corpse"):
        log_and_raise(
            ValidationError,
            f"Invalid source_type: {source_type}. Must be 'environment', 'equipment', or 'corpse'",
            operation="create_container",
            source_type=source_type,
            details={"source_type": source_type},
            user_friendly="Invalid container type",
        )

    # Validate capacity_slots
    if capacity_slots < 1 or capacity_slots > 20:
        log_and_raise(
            ValidationError,
            f"Invalid capacity_slots: {capacity_slots}. Must be between 1 and 20",
            operation="create_container",
            capacity_slots=capacity_slots,
            details={"capacity_slots": capacity_slots},
            user_friendly="Invalid container capacity",
        )

    # Validate lock_state
    if lock_state not in ("unlocked", "locked", "sealed"):
        log_and_raise(
            ValidationError,
            f"Invalid lock_state: {lock_state}. Must be 'unlocked', 'locked', or 'sealed'",
            operation="create_container",
            lock_state=lock_state,
            details={"lock_state": lock_state},
            user_friendly="Invalid lock state",
        )

    try:
        # Generate UUID for container
        container_id = UUID(int=0)  # Will be generated by database DEFAULT
        current_time = datetime.now(UTC).replace(tzinfo=None)

        # Prepare JSONB data (items are now stored in container_contents table)
        metadata_jsonb = json.dumps(metadata_json or {})
        allowed_roles_jsonb = json.dumps(allowed_roles or [])

        # Insert container (items_json column removed - items go in container_contents)
        # Convert UUID objects to strings for psycopg2 compatibility
        owner_id_str = str(owner_id) if owner_id and isinstance(owner_id, UUID) else owner_id
        entity_id_str = str(entity_id) if entity_id and isinstance(entity_id, UUID) else entity_id

        cursor = conn.cursor(cursor_factory=RealDictCursor)
        cursor.execute(
            """
            INSERT INTO containers (
                source_type, owner_id, room_id, entity_id, lock_state,
                capacity_slots, weight_limit, decay_at, allowed_roles,
                metadata_json, container_item_instance_id, created_at, updated_at
            ) VALUES (
                %s, %s, %s, %s, %s, %s, %s, %s, %s::jsonb, %s::jsonb, %s, %s, %s
            )
            RETURNING container_instance_id, created_at, updated_at
            """,
            (
                source_type,
                owner_id_str,
                room_id,
                entity_id_str,
                lock_state,
                capacity_slots,
                weight_limit,
                decay_at,
                allowed_roles_jsonb,
                metadata_jsonb,
                container_item_instance_id,
                current_time,
                current_time,
            ),
        )
        row = cursor.fetchone()
        conn.commit()
        cursor.close()

        if not row:
            log_and_raise(
                DatabaseError,
                "Failed to create container - no ID returned",
                operation="create_container",
                source_type=source_type,
                user_friendly="Failed to create container",
            )

        # RealDictCursor returns a dict-like row
        container_id = row["container_instance_id"]
        created_at = row["created_at"]
        updated_at = row["updated_at"]

        # Add items to container_contents using stored procedure
        # First ensure item instances exist, then add them to container
        if items_json:
            cursor = conn.cursor()
            for position, item in enumerate(items_json):
                item_instance_id = item.get("item_instance_id") or item.get("item_id")
                prototype_id = item.get("item_id") or item.get("prototype_id")

                if item_instance_id and prototype_id:
                    # Ensure item instance exists in database before adding to container
                    # This is required for foreign key constraint on container_contents
                    from .item_instance_persistence import ensure_item_instance

                    try:
                        ensure_item_instance(
                            conn,
                            item_instance_id=item_instance_id,
                            prototype_id=prototype_id,
                            owner_type="container",
                            owner_id=str(container_id),
                            quantity=item.get("quantity", 1),
                            metadata=item.get("metadata", {}),
                        )
                    except (DatabaseError, ValidationError) as e:
                        logger.warning(
                            "Failed to ensure item instance exists, skipping item",
                            item_instance_id=item_instance_id,
                            prototype_id=prototype_id,
                            error=str(e),
                        )
                        continue

                    # Now add item to container
                    cursor.execute(
                        "SELECT add_item_to_container(%s, %s, %s)",
                        (container_id, item_instance_id, position),
                    )
            conn.commit()
            cursor.close()

        logger.info(
            "Container created",
            container_id=str(container_id),
            source_type=source_type,
            room_id=room_id,
            entity_id=str(entity_id) if entity_id else None,
        )

        # Get container with items using get_container (which uses stored procedure)
        return get_container(conn, container_id) or ContainerData(
            container_instance_id=container_id,
            source_type=source_type,
            owner_id=owner_id,
            room_id=room_id,
            entity_id=entity_id,
            lock_state=lock_state,
            capacity_slots=capacity_slots,
            weight_limit=weight_limit,
            decay_at=decay_at,
            allowed_roles=allowed_roles or [],
            items_json=items_json or [],
            metadata_json=metadata_json or {},
            created_at=created_at,
            updated_at=updated_at,
        )

    except psycopg2.Error as e:
        conn.rollback()
        log_and_raise(
            DatabaseError,
            f"Database error creating container: {e}",
            operation="create_container",
            source_type=source_type,
            details={"error": str(e), "source_type": source_type},
            user_friendly="Failed to create container",
        )


def get_container(conn: Any, container_id: UUID) -> ContainerData | None:
    """
    Get a container by ID.

    Args:
        conn: Database connection
        container_id: Container UUID

    Returns:
        ContainerData: Container data if found, None otherwise

    Raises:
        DatabaseError: If database operation fails
    """
    try:
        cursor = conn.cursor(cursor_factory=RealDictCursor)
        # Convert UUID to string for psycopg2 compatibility
        container_id_str = str(container_id) if isinstance(container_id, UUID) else container_id
        cursor.execute(
            """
            SELECT
                container_instance_id, source_type, owner_id, room_id, entity_id,
                lock_state, capacity_slots, weight_limit, decay_at,
                allowed_roles, metadata_json, created_at, updated_at,
                container_item_instance_id
            FROM containers
            WHERE container_instance_id = %s
            """,
            (container_id_str,),
        )
        row = cursor.fetchone()
        cursor.close()

        if not row:
            return None

        # Fetch items directly from normalized tables
        items_json = fetch_container_items(conn, container_id)

        # Convert row to ContainerData
        return ContainerData(
            container_instance_id=row["container_instance_id"],
            source_type=row["source_type"],
            owner_id=row["owner_id"],
            room_id=row["room_id"],
            entity_id=row["entity_id"],
            lock_state=row["lock_state"],
            capacity_slots=row["capacity_slots"],
            weight_limit=row["weight_limit"],
            decay_at=row["decay_at"],
            allowed_roles=parse_jsonb_column(row["allowed_roles"], []),
            items_json=items_json,
            metadata_json=parse_jsonb_column(row["metadata_json"], {}),
            created_at=row["created_at"],
            updated_at=row["updated_at"],
        )

    except psycopg2.Error as e:
        log_and_raise(
            DatabaseError,
            f"Database error retrieving container: {e}",
            operation="get_container",
            container_id=str(container_id),
            details={"container_id": str(container_id), "error": str(e)},
            user_friendly="Failed to retrieve container",
        )


def update_container(
    conn: Any,
    container_id: UUID,
    items_json: list[dict[str, Any]] | None = None,
    lock_state: str | None = None,
    metadata_json: dict[str, Any] | None = None,
) -> ContainerData | None:
    """
    Update a container's items, lock state, or metadata.

    Args:
        conn: Database connection
        container_id: Container UUID
        items_json: New items list (optional)
        lock_state: New lock state (optional)
        metadata_json: New metadata (optional)

    Returns:
        ContainerData: Updated container data if found, None otherwise

    Raises:
        ValidationError: If validation fails
        DatabaseError: If database operation fails
    """
    validate_lock_state(lock_state)

    try:
        container_id_str = str(container_id) if isinstance(container_id, UUID) else container_id

        updates: list[str] = []
        params: list[Any] = []
        current_time = datetime.now(UTC).replace(tzinfo=None)
        cursor = conn.cursor()

        if items_json is not None:
            update_container_items(cursor, container_id_str, items_json, conn)

        if lock_state is not None:
            updates.append("lock_state = %s")
            params.append(lock_state)

        if metadata_json is not None:
            updates.append("metadata_json = %s::jsonb")
            params.append(json.dumps(metadata_json))

        row = None

        if updates:
            query = build_update_query(updates, params, container_id_str, current_time)
            # nosemgrep: python.lang.security.audit.sql-injection.sql-injection
            # nosec B608: Using psycopg2.sql.SQL for safe SQL construction (column names are hardcoded)
            cursor.execute(query, params)
            row = cursor.fetchone()
        elif items_json is not None:
            query = build_update_query(updates, params, container_id_str, current_time)
            # nosemgrep: python.lang.security.audit.sql-injection.sql-injection
            # nosec B608: Using psycopg2.sql.SQL for safe SQL construction (column names are hardcoded)
            cursor.execute(query, params)
            row = cursor.fetchone()

        conn.commit()
        cursor.close()

        if not row:
            return None

        logger.info(
            "Container updated",
            container_id=str(container_id),
            updated_fields=len(updates) - 1,  # Exclude updated_at
        )

        return get_container(conn, container_id)

    except psycopg2.Error as e:
        conn.rollback()
        log_and_raise(
            DatabaseError,
            f"Database error updating container: {e}",
            operation="update_container",
            container_id=str(container_id),
            details={"container_id": str(container_id), "error": str(e)},
            user_friendly="Failed to update container",
        )


def delete_container(conn: Any, container_id: UUID) -> bool:
    """
    Delete a container.

    Args:
        conn: Database connection
        container_id: Container UUID

    Returns:
        bool: True if container was deleted, False if not found

    Raises:
        DatabaseError: If database operation fails
    """
    try:
        cursor = conn.cursor()
        # Convert UUID to string for psycopg2 compatibility
        container_id_str = str(container_id) if isinstance(container_id, UUID) else container_id
        cursor.execute(
            "DELETE FROM containers WHERE container_instance_id = %s RETURNING container_instance_id",
            (container_id_str,),
        )
        row = cursor.fetchone()
        conn.commit()
        cursor.close()

        if row:
            logger.info("Container deleted", container_id=str(container_id))
            return True
        return False

    except psycopg2.Error as e:
        conn.rollback()
        log_and_raise(
            DatabaseError,
            f"Database error deleting container: {e}",
            operation="delete_container",
            container_id=str(container_id),
            details={"container_id": str(container_id), "error": str(e)},
            user_friendly="Failed to delete container",
        )
